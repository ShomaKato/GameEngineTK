///-------------------------------------------------------------------
//*
//*	@作成日		2017/06/19
//*
//*	@名前		CollisionNode.cpp
//*
//* @役割		衝突判定のクラス
//*
//*	@著者		加藤 彰馬
//*
///-------------------------------------------------------------------

// ヘッダのインクルード
#include "pch.h"
#include "CollisionNode.h"

// 名前空間
using namespace DirectX::SimpleMath;
// 静的メンバ変数
bool CollisionNode::m_debugVisible = true;
/* staticメンバ変数の作り方・staticは消す。グローバル関数みたいに書く。 */


////----------------------------------------------------------------------
////! @関数名：SetParent
////!
////! @役割：当たり判定をモデルに親子付する
////!
////! @引数：球A(Sphere)と球B(Sphere)
////!
////! @戻り値：ヒットしたか否か
////----------------------------------------------------------------------
void CollisionNode::SetParent(Obj3d * parent)
{
	// 自分の親を、親に登録
	m_obj.SetParent(parent);
}



//* ぶっちゃけ、メンバ変数の初期化のためだけに作る
SphereNode::SphereNode()
{
	// デフォルト半径を１メートルに
	m_localRadius = 1.0f;
}

////----------------------------------------------------------------------
////! @関数名：Initialize
////!
////! @役割：球状当たり判定の初期化
////!
////! @引数：なし(void)
////!
////! @戻り値：なし(void)
////----------------------------------------------------------------------
void SphereNode::Initialize()
{
	// デバッグ用表示モデルを読み込む
	m_obj.LoadModel(L"Resources\\SphereNode.cmo");
}

////----------------------------------------------------------------------
////! @関数名：Update
////!
////! @役割：球状当たり判定の更新
////!
////! @引数：なし(void)
////!
////! @戻り値：なし(void)
////----------------------------------------------------------------------
void SphereNode::Update()
{
	m_obj.SetTranslation(m_Trans);
	m_obj.SetScale(Vector3(m_localRadius));	/* ローカル半径はvector3ではないので必要 */

	m_obj.Update();




	//* 6/22 このままだと敵が開始直後に原点に出てしまう判定なので、色々追加

	{// ワールド座標での当たり判定球を計算
		// 計算済みのワールド行列を取得
		const Matrix worldm = m_obj.GetWorld();	/* GetWorldがコンストの値を受け取るものなので、*/
												/* こっちもコンストにするとコピーにならず無駄が少ない */
		// モデル座標系での中心点
		Vector3 center(0, 0, 0);
		// モデル座標系での球の右端		/* 右でなくてもいい。球の表面部分が一点だけほしい */
		Vector3 right(1, 0, 0);

		// ワールド座標に変換
		center = Vector3::Transform(center, worldm);	/* 変換したい座標×ワールド座標でおｋ */
		right = Vector3::Transform(right, worldm);
		/* 上記の二点間の距離＝球の半径となる */

		// 当たり判定球に結果を代入
		Sphere::Center = center;	/* 大文字センターは、スフィアクラスの中心座標変数 */
		Sphere::Radius = Vector3::Distance(center, right);	/* 半径は、上の二点間の距離 */

		//* つまりワールド座標に変換した中心座標と半径があればいい

		
	}
}

////----------------------------------------------------------------------
////! @関数名：Draw
////!
////! @役割：球状当たり判定の描画
////!
////! @引数：なし(void)
////!
////! @戻り値：なし(void)
////----------------------------------------------------------------------
void SphereNode::Draw()
{
	m_obj.Draw();
}
